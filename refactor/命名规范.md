# 前言

​	一个好的命名，能够让代码的概念清晰， 增加代码的表达力，让代码更易懂。命名并不是一个简单的事情，命名的过程本身就是一个抽象和思考的过程，当我们不能给一个模块、一个对象、一个函数等找到合适的名称的时候， 说明我们对问题理解的还不够透彻，需要重新去挖掘问题的本质， 对问题域进行重新分析和抽象，甚至需要重新设计和重构代码。

​	本文主要是总结不同文章中提及的关于命名的一些重点，学习以提高代码规范性。

# 代码精进之路：从码农到工匠 命名

本小节主要是总结代码精进之路：从码农到工匠的第一章命名，若想查看全部内容， 请查看对应的文章。

​	命名其实是一件很难的事情， 因为命名的过程本身就是一个抽象和思考的过程，在工作中， 当我们不能给一个模块、一个对象、一个函数，甚至一个变量找到合适的名称的时候， 往往说明我们对问题的理解还不够透彻，需要重新去挖掘问题的本质， 对问题域进行重新分析和抽象， 有时还要调整设计和重构代码。因为好的命名是我们写出好代码的基础。一个好的命名可以起到代码即文档的作用，如果想不到一个合适的名字， 意味着代码存在“坏味道”， 设计有问题。

## 变量名

​	变量名应该是名词，能够正确地描述业务， 有表达力。 如果一个变量名需要注释来说明， 那么很可能说明命名就有问题。

```java
int d; //表示过去的天数
```

上面的命名很明显就有问题， 以下是好的命名

```java
int elapsedTimeInDays;
int secondsPerDay = 86400;
int pageSize = 10;
```

这样做还有一个好处， 即代码的可搜索性，在代码中查找pageSize很容易， 但是想找到10就很麻烦了， 因为它可能是某些注释或者常量定义的一部分， 出现在不同作用的各种表达式中。

## 函数名

函数命名要具体，空泛的命名没有意义。例如processData()就不是一个好的命名， 因为所有的方法都是对数据的处理，相比之下，validateUserCredentials()就好很多。

函数命名要体现做什么， 而不是怎么做，并且命名应该提升抽象层次， 体现业务语义。

例如将把雇员信息存到栈中，现在要获取最近存储的一个雇员信息， 显然getLastestEmployee()就比popRecord()要好，屏蔽了底层细节。

## 类名

​	类是对数据和操作的封装， 对于一个应用系统， 可以将类分为两大类：实体类和辅助类。

​	实体类承载了核心业务数据和核心业务逻辑， 其命名要能充分体现业务语义并在团队内达成共识，如Customer，Bank和Employee等

​	辅助类是辅佐实体类一起完成业务逻辑的，其命名要能通过后缀来体现功能。如控制陆游的控制类CustomerController。 提供服务的CustomerService和进行数据库交互的CustomerRepository。

​	对于辅助类， 尽量不要用Helper、Util之类的后缀， 因为其含义太过笼统， 容易破坏SRP(单一职责原则)。例如对于CSV的处理可以从

```java
CSVHelper.parse(String)
CSVHelper(int[])
```

 变成

```java
CSVParser.parse(String)
CSVBuilder.create(int[])
```

## 包名

​	包(Package)代表了一组有关系的类的集合，起到分类组合和命名空间的作用。

​	包名应该能够反映一组类在更高抽象层次上的联系。例如，有一组类Apple、Pear、Orange，我们可以将他们放到一个包中， 命名为fruit。包的命名要适中， 不能太抽象， 也不能太具体。







# 阿里巴巴开发手册命名风格

本小节主要是总结阿里巴巴Java开发手册1.7.0（嵩山版）编码规范-命名风格和常量定义，若想查看全部内容， 请查看对应的文章。

1. 【强制】类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。

   <font color='green'>正例：</font>ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion

   <font color='red'>反例：</font>forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion

2. 【强制】常量命名全部大写，单词间用下划线隔开，**力求语义表达完整清楚，不要嫌名字长。**

​		正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME

​		反例：MAX_COUNT / EXPIRED_TIME

3. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类

   命名以它要测试的类的名称开始，以 Test 结尾。

4. 【强制】POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列

   化错误。

   说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的变量采用 is_xxx 的命名方式，所以，需要

   在`<resultMap>`设置从 is_xxx 到 xxx 的映射关系。

​		反例：定义为基本数据类型 **Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时**

​		**候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常**。

5. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用

   单数形式，但是类名如果有复数含义，类名可以使用复数形式。

   正例：应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的

   框架结构）

6. 【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。

   正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT

   反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD

7. 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。

   说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。

   正例：

   ```java
   public class OrderFactory;
   public class LoginProxy;
   public class ResourceObserver;
   ```

8. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁

   性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定

   与接口方法相关，并且是整个应用的基础常量。

   正例：接口方法签名 void commit();

   ​           接口基础常量 String COMPANY = "alibaba";

   反例：接口方法定义 public abstract void f();

   ​           说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。

9. 接口和实现类的命名有两套规则：

   1）【强制】**对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口**，内部的实现类用

   Impl 的后缀与接口区别。

   正例：CacheServiceImpl 实现 CacheService 接口。

   2）【推荐】**如果是形容能力的接口名称，取对应的形容词为接口名**（通常是–able 的形容词）。

   正例：AbstractTranslator 实现 Translatable 接口。

10. 【参考】**枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。**

    说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。

    正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。

11.  【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。

    说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。

    正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 SystemConfigConsts 下。

12. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包

    内共享常量、类内共享常量。

    1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。

    2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。

    ​	反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量：

    ​	类 A 中：public static final String YES = "yes";

    ​	类 B 中：public static final String YES = "y";

    ​	A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。

    3） 子工程内部共享常量：即在当前子工程的 constant 目录下。

    4） 包内共享常量：即在当前包下单独的 constant 目录下。

    5） 类内共享常量：直接在类内部 private static final 定义。

# 



# 参考

1. 阿里巴巴Java开发手册1.7.0（嵩山版）编码规范-命名风格和常量定义
2. 代码精进之路：从码农到工匠 第一章命名